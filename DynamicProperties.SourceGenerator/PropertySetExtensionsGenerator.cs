// PropertySetExtensionsGenerator.cs
// <auto-generated> Generates extension methods for DynamicProperty.PropertySet based on decorated enums, including group aggregates </auto-generated>
using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DynamicProperty.SourceGen
{
    [Generator]
    public sealed class PropertySetExtensionsGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {
                var compilation = context.Compilation;

                // Collect enums from this compilation
                var localEnums = compilation.SyntaxTrees
                    .SelectMany(st =>
                    {
                        var sm = compilation.GetSemanticModel(st);
                        return st.GetRoot()
                                 .DescendantNodes()
                                 .OfType<EnumDeclarationSyntax>()
                                 .Select(ed => sm.GetDeclaredSymbol(ed))
                                 .OfType<INamedTypeSymbol>();
                    })
                    .ToList();

                // Also scan referenced assemblies (metadata)
                foreach (var asm in compilation.SourceModule.ReferencedAssemblySymbols)
                    CollectEnumsFromNamespace(asm.GlobalNamespace, localEnums);

                if (localEnums.Count == 0) return;

                // Ensure the consumer assembly references DynamicProperty.Runtime
                var propertySet = compilation.GetTypeByMetadataName("DynamicProperty.PropertySet");
                if (propertySet == null) return;

                foreach (var enumSym in localEnums)
                {
                    if (enumSym.TypeKind != TypeKind.Enum) continue;

                    var sb = new StringBuilder(16 * 1024);
                    var enumName = enumSym.Name;
                    var ns = GetEnclosingNamespace(enumSym) ?? "Global";
                    var extensionsClassName = $"{enumName}PropertySetExtensions";
                    var enumFqn = enumSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    sb.AppendLine("// <auto-generated/>");
                    sb.AppendLine("using System;");
                    sb.AppendLine("using DynamicProperty;");
                    sb.AppendLine();

                    if (ns != "Global")
                    {
                        sb.Append("namespace ").Append(ns).AppendLine();
                        sb.AppendLine("{");
                    }

                    sb.Append("    public static class ").Append(extensionsClassName).AppendLine();
                    sb.AppendLine("    {");

                    bool emittedAny = false;
                    var seenNames = new System.Collections.Generic.HashSet<string>(StringComparer.Ordinal);

                    // ---------- pass 1: per-member methods + collect grouped ----------
                    var grouped = new System.Collections.Generic.Dictionary<string, GroupBucket>(StringComparer.OrdinalIgnoreCase);

                    foreach (var field in enumSym.GetMembers().OfType<IFieldSymbol>())
                    {
                        if (field.ConstantValue is null) continue;

                        var ptAttr = field.GetAttributes().FirstOrDefault(a =>
                            a.AttributeClass?.Name == "PropertyTypeAttribute" ||
                            a.AttributeClass?.ToDisplayString().EndsWith(".PropertyTypeAttribute") == true);
                        if (ptAttr is null) continue;

                        ITypeSymbol? declaredType = null;
                        foreach (var arg in ptAttr.ConstructorArguments)
                        {
                            if (arg.Kind == TypedConstantKind.Type && arg.Value is ITypeSymbol ts)
                            {
                                declaredType = ts; break;
                            }
                        }
                        if (declaredType is null)
                        {
                            context.ReportDiagnostic(DiagMissingType(field));
                            continue;
                        }

                        // Optional [Group("Name")]
                        string? groupName = null;
                        var grpAttr = field.GetAttributes().FirstOrDefault(a =>
                            a.AttributeClass?.Name == "GroupAttribute" ||
                            a.AttributeClass?.ToDisplayString().EndsWith(".GroupAttribute") == true);
                        if (grpAttr != null && grpAttr.ConstructorArguments.Length > 0)
                        {
                            var arg0 = grpAttr.ConstructorArguments[0];
                            if (arg0.Value is string s && !string.IsNullOrWhiteSpace(s))
                                groupName = s.Trim();
                        }

                        var kind = Classify(declaredType);
                        if (kind == ValueKind.Unknown)
                        {
                            context.ReportDiagnostic(DiagUnsupportedType(field, declaredType));
                            continue;
                        }

                        var memberName = field.Name;
                        var safeName = SafeIdentifier(memberName);
                        var idExpr = $"(int){enumFqn}.{memberName}";

                        // emit scalar methods (including vector/color components as floats)
                        EmitExtensionsForMember(sb, safeName, idExpr, kind, declaredType);
                        emittedAny = true;

                        // collect into group buckets when type requests an aggregate
                        var aggKind = AggregateKindFor(declaredType);
                        if (aggKind != AggregateKind.None && groupName != null)
                        {
                            if (!grouped.TryGetValue(groupName, out var bucket))
                            {
                                bucket = new GroupBucket(groupName, aggKind, enumFqn);
                                grouped[groupName] = bucket;
                            }
                            bucket.AddComponent(field, idExpr);
                        }
                    }

                    // ---------- pass 2: aggregate methods for groups ----------
                    foreach (var kv in grouped)
                    {
                        var bucket = kv.Value;
                        if (!bucket.TryFinalize(context)) continue; // validate + order

                        EmitAggregate(sb, bucket);
                        emittedAny = true;
                    }

                    sb.AppendLine("    }");

                    if (ns != "Global")
                        sb.AppendLine("}");

                    if (emittedAny)
                        context.AddSource($"{extensionsClassName}.g.cs", sb.ToString());
                }
            }
            catch (Exception ex)
            {
                context.AddSource("PropertySetExtensionsGenerator.Error.g.cs",
                    $"// <auto-generated/> Generator error: {ex}");
            }
        }

        // ---------- group support ----------

        private enum AggregateKind { None, Vector2, Vector3, Vector4, Color }

        private sealed class GroupBucket
        {
            public readonly string GroupName;
            public readonly AggregateKind Kind;
            public readonly string EnumFqn;

            // component slots; each holds (symbol, idExpr)
            public (IFieldSymbol sym, string id)? C0;
            public (IFieldSymbol sym, string id)? C1;
            public (IFieldSymbol sym, string id)? C2;
            public (IFieldSymbol sym, string id)? C3;

            public GroupBucket(string name, AggregateKind kind, string enumFqn)
            { GroupName = name; Kind = kind; EnumFqn = enumFqn; }

            public void AddComponent(IFieldSymbol field, string idExpr)
            {
                var idx = ComponentIndex(field.Name, Kind);
                switch (idx)
                {
                    case 0: C0 = (field, idExpr); break;
                    case 1: C1 = (field, idExpr); break;
                    case 2: C2 = (field, idExpr); break;
                    case 3: C3 = (field, idExpr); break;
                    default:
                        // put into first empty if suffix wasn’t recognized
                        if (C0 is null) C0 = (field, idExpr);
                        else if (C1 is null) C1 = (field, idExpr);
                        else if (C2 is null) C2 = (field, idExpr);
                        else if (C3 is null) C3 = (field, idExpr);
                        break;
                }
            }

            public bool TryFinalize(GeneratorExecutionContext ctx)
            {
                // For vectors require X/Y for v2, X/Y/Z for v3, etc.
                switch (Kind)
                {
                    case AggregateKind.Vector2: return C0 is not null && C1 is not null;
                    case AggregateKind.Vector3: return C0 is not null && C1 is not null && C2 is not null;
                    case AggregateKind.Vector4: return C0 is not null && C1 is not null && C2 is not null && C3 is not null;
                    case AggregateKind.Color: return C0 is not null && C1 is not null && C2 is not null; // A optional
                    default: return false;
                }
            }
        }

        private static int ComponentIndex(string name, AggregateKind kind)
        {
            var n = name.Trim().ToLowerInvariant();
            bool EndsWith(string s) => n.EndsWith(" " + s) || n.EndsWith("." + s) || n.EndsWith(s);

            if (kind == AggregateKind.Color)
            {
                if (EndsWith("r")) return 0;
                if (EndsWith("g")) return 1;
                if (EndsWith("b")) return 2;
                if (EndsWith("a")) return 3;
                return -1;
            }
            else
            {
                if (EndsWith("x")) return 0;
                if (EndsWith("y")) return 1;
                if (EndsWith("z")) return 2;
                if (EndsWith("w")) return 3;
                return -1;
            }
        }

        private static AggregateKind AggregateKindFor(ITypeSymbol t)
        {
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::UnityEngine.Vector2") return AggregateKind.Vector2;
            if (fqn == "global::UnityEngine.Vector3") return AggregateKind.Vector3;
            if (fqn == "global::UnityEngine.Vector4") return AggregateKind.Vector4;
            if (fqn == "global::UnityEngine.Color") return AggregateKind.Color;
            return AggregateKind.None;
        }

        private static string SanitizeGroupName(string s)
        {
            // Turn "Spawn Position" => "SpawnPosition"
            var sb = new StringBuilder(s.Length);
            foreach (var ch in s)
                if (!char.IsWhiteSpace(ch)) sb.Append(ch);
            // Ensure leading letter is identifier-safe
            if (sb.Length == 0 || SyntaxFacts.GetKeywordKind(sb.ToString()) != SyntaxKind.None)
                return "_" + sb.ToString();
            return sb.ToString();
        }

        private static void EmitAggregate(StringBuilder sb, GroupBucket g)
        {
            var name = SanitizeGroupName(g.GroupName);

            switch (g.Kind)
            {
                case AggregateKind.Vector2:
                    sb.AppendLine($"        public static global::UnityEngine.Vector2 {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float x = set.TryGetFloat({g.C0!.Value.id}, out var vx) ? vx : 0f;");
                    sb.AppendLine($"            float y = set.TryGetFloat({g.C1!.Value.id}, out var vy) ? vy : 0f;");
                    sb.AppendLine("            return new global::UnityEngine.Vector2(x,y);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Vector2 v)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, v.x);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, v.y);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;

                case AggregateKind.Vector3:
                    sb.AppendLine($"        public static global::UnityEngine.Vector3 {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float x = set.TryGetFloat({g.C0!.Value.id}, out var vx) ? vx : 0f;");
                    sb.AppendLine($"            float y = set.TryGetFloat({g.C1!.Value.id}, out var vy) ? vy : 0f;");
                    sb.AppendLine($"            float z = set.TryGetFloat({g.C2!.Value.id}, out var vz) ? vz : 0f;");
                    sb.AppendLine("            return new global::UnityEngine.Vector3(x,y,z);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Vector3 v)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, v.x);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, v.y);");
                    sb.AppendLine($"            set.SetFloat({g.C2!.Value.id}, v.z);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;

                case AggregateKind.Vector4:
                    sb.AppendLine($"        public static global::UnityEngine.Vector4 {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float x = set.TryGetFloat({g.C0!.Value.id}, out var vx) ? vx : 0f;");
                    sb.AppendLine($"            float y = set.TryGetFloat({g.C1!.Value.id}, out var vy) ? vy : 0f;");
                    sb.AppendLine($"            float z = set.TryGetFloat({g.C2!.Value.id}, out var vz) ? vz : 0f;");
                    sb.AppendLine($"            float w = set.TryGetFloat({g.C3!.Value.id}, out var vw) ? vw : 0f;");
                    sb.AppendLine("            return new global::UnityEngine.Vector4(x,y,z,w);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Vector4 v)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, v.x);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, v.y);");
                    sb.AppendLine($"            set.SetFloat({g.C2!.Value.id}, v.z);");
                    sb.AppendLine($"            set.SetFloat({g.C3!.Value.id}, v.w);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id}) || set.ContainsAny({g.C3!.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;

                case AggregateKind.Color:
                    sb.AppendLine($"        public static global::UnityEngine.Color {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float r = set.TryGetFloat({g.C0!.Value.id}, out var vr) ? vr : 0f;");
                    sb.AppendLine($"            float g_ = set.TryGetFloat({g.C1!.Value.id}, out var vg) ? vg : 0f;");
                    sb.AppendLine($"            float b = set.TryGetFloat({g.C2!.Value.id}, out var vb) ? vb : 0f;");
                    if (g.C3 is null)
                        sb.AppendLine($"            float a = 1f;");
                    else
                        sb.AppendLine($"            float a = set.TryGetFloat({g.C3.Value.id}, out var va) ? va : 1f;");
                    sb.AppendLine("            return new global::UnityEngine.Color(r,g_,b,a);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Color c)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, c.r);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, c.g);");
                    sb.AppendLine($"            set.SetFloat({g.C2!.Value.id}, c.b);");
                    if (g.C3 is not null)
                        sb.AppendLine($"            set.SetFloat({g.C3.Value.id}, c.a);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    if (g.C3 is null)
                        sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id});");
                    else
                        sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id}) || set.ContainsAny({g.C3.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;
            }
        }

        // ---------- general utilities ----------

        private static void CollectEnumsFromNamespace(INamespaceSymbol ns, System.Collections.Generic.List<INamedTypeSymbol> sink)
        {
            foreach (var t in ns.GetTypeMembers())
                if (t.TypeKind == TypeKind.Enum) sink.Add(t);
            foreach (var child in ns.GetNamespaceMembers())
                CollectEnumsFromNamespace(child, sink);
        }

        private static string? GetEnclosingNamespace(INamedTypeSymbol t)
        {
            var ns = t.ContainingNamespace;
            if (ns == null || ns.IsGlobalNamespace) return null;
            return ns.ToDisplayString();
        }

        private enum ValueKind { Int32, Single, Boolean, Int64, Double, DateTime, TimeSpan, Enum32, Unknown }

        private static ValueKind Classify(ITypeSymbol t)
        {
            switch (t.SpecialType)
            {
                case SpecialType.System_Int32: return ValueKind.Int32;
                case SpecialType.System_Single: return ValueKind.Single;
                case SpecialType.System_Boolean: return ValueKind.Boolean;
                case SpecialType.System_Int64: return ValueKind.Int64;
                case SpecialType.System_Double: return ValueKind.Double;
                case SpecialType.System_DateTime: return ValueKind.DateTime;
            }
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::System.TimeSpan") return ValueKind.TimeSpan;
            if (fqn == "global::UnityEngine.Vector2" || fqn == "global::UnityEngine.Vector3" ||
                fqn == "global::UnityEngine.Vector4" || fqn == "global::UnityEngine.Color")
                return ValueKind.Single; // components are floats
            if (t.TypeKind == TypeKind.Enum) return ValueKind.Enum32;
            return ValueKind.Unknown;
        }

        private static void EmitExtensionsForMember(StringBuilder sb, string name, string idExpr, ValueKind kind, ITypeSymbol declaredType)
        {
            var typeName = GetClrTypeName(kind, declaredType);

            // Getter
            sb.Append("        public static ").Append(typeName).Append(' ').Append(name)
              .Append("(this DynamicProperty.PropertySet set)").AppendLine();
            sb.AppendLine("        {");
            switch (kind)
            {
                case ValueKind.Int32: sb.AppendLine($"            return set.TryGetInt({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Single: sb.AppendLine($"            return set.TryGetFloat({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Boolean: sb.AppendLine($"            return set.TryGetBool({idExpr}, out var v) && v;"); break;
                case ValueKind.Int64: sb.AppendLine($"            return set.TryGetLong({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Double: sb.AppendLine($"            return set.TryGetDouble({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.DateTime: sb.AppendLine($"            return set.TryGetDateTime({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.TimeSpan: sb.AppendLine($"            return set.TryGetTimeSpan({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Enum32:
                    var enumTypeName = declaredType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine($"            return set.TryGetEnum32<{enumTypeName}>({idExpr}, out var v) ? v : default;");
                    break;
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Setter
            sb.Append("        public static void Set").Append(name)
              .Append("(this DynamicProperty.PropertySet set, ").Append(typeName).Append(" value)").AppendLine();
            sb.AppendLine("        {");
            switch (kind)
            {
                case ValueKind.Int32: sb.AppendLine($"            set.SetInt({idExpr}, value);"); break;
                case ValueKind.Single: sb.AppendLine($"            set.SetFloat({idExpr}, value);"); break;
                case ValueKind.Boolean: sb.AppendLine($"            set.SetBool({idExpr}, value);"); break;
                case ValueKind.Int64: sb.AppendLine($"            set.SetLong({idExpr}, value);"); break;
                case ValueKind.Double: sb.AppendLine($"            set.SetDouble({idExpr}, value);"); break;
                case ValueKind.DateTime: sb.AppendLine($"            set.SetDateTime({idExpr}, value);"); break;
                case ValueKind.TimeSpan: sb.AppendLine($"            set.SetTimeSpan({idExpr}, value);"); break;
                case ValueKind.Enum32:
                    var enumTypeName = declaredType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine($"            set.SetEnum32<{enumTypeName}>({idExpr}, value);");
                    break;
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Presence
            sb.Append("        public static bool Has").Append(name)
              .Append("(this DynamicProperty.PropertySet set)").AppendLine();
            sb.AppendLine("        {");
            sb.AppendLine($"            return set.ContainsAny({idExpr});");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private static string GetClrTypeName(ValueKind kind, ITypeSymbol declaredType) =>
            kind switch
            {
                ValueKind.Int32 => "int",
                ValueKind.Single => "float",
                ValueKind.Boolean => "bool",
                ValueKind.Int64 => "long",
                ValueKind.Double => "double",
                ValueKind.DateTime => "global::System.DateTime",
                ValueKind.TimeSpan => "global::System.TimeSpan",
                ValueKind.Enum32 => declaredType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                _ => "object"
            };

        private static string SafeIdentifier(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return "_";
            if (SyntaxFacts.GetKeywordKind(raw) != SyntaxKind.None) return "@" + raw;
            return raw.Replace('<', '_').Replace('>', '_');
        }

        // Diagnostics
        private static Diagnostic DiagMissingType(IFieldSymbol field) =>
            Diagnostic.Create(new DiagnosticDescriptor(
                id: "DP1001", title: "PropertyType attribute missing type",
                messageFormat: "Enum member '{0}' has [PropertyType(...)] but no typeof(T) argument.",
                category: "DynamicProperty.SourceGen",
                defaultSeverity: DiagnosticSeverity.Warning, isEnabledByDefault: true),
                field.Locations.FirstOrDefault(), field.Name);

        private static Diagnostic DiagUnsupportedType(IFieldSymbol field, ITypeSymbol type) =>
            Diagnostic.Create(new DiagnosticDescriptor(
                id: "DP1002", title: "Unsupported PropertyType",
                messageFormat: "Enum member '{0}' uses unsupported PropertyType '{1}'.",
                category: "DynamicProperty.SourceGen",
                defaultSeverity: DiagnosticSeverity.Warning, isEnabledByDefault: true),
                field.Locations.FirstOrDefault(), field.Name, type.ToDisplayString());

        private static Diagnostic DiagNameCollision(IFieldSymbol field, string name) =>
            Diagnostic.Create(new DiagnosticDescriptor(
                id: "DP1003", title: "Generated method name collision",
                messageFormat: "Generated method name '{0}' collides with another. Consider renaming enum members.",
                category: "DynamicProperty.SourceGen",
                defaultSeverity: DiagnosticSeverity.Warning, isEnabledByDefault: true),
                field.Locations.FirstOrDefault(), name);
    }
}
