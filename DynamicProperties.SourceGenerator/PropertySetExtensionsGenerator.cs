// PropertySetExtensionsGenerator.cs
// <auto-generated> Generates extension methods for DynamicProperty.PropertySet based on decorated enums,
// including vector/color group aggregates and [Flags] helpers. </auto-generated>
using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DynamicProperty.SourceGen
{
    [Generator]
    public sealed class PropertySetExtensionsGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {
                var compilation = context.Compilation;

                // Collect enums declared in this compilation
                var enums = compilation.SyntaxTrees
                    .SelectMany(st =>
                    {
                        var sm = compilation.GetSemanticModel(st);
                        return st.GetRoot()
                                 .DescendantNodes()
                                 .OfType<EnumDeclarationSyntax>()
                                 .Select(ed => sm.GetDeclaredSymbol(ed))
                                 .OfType<INamedTypeSymbol>();
                    })
                    .ToList();

                // Also scan referenced assemblies (metadata)
                foreach (var asm in compilation.SourceModule.ReferencedAssemblySymbols)
                    CollectEnumsFromNamespace(asm.GlobalNamespace, enums);

                if (enums.Count == 0) return;

                // Must reference the runtime type to generate usable code
                var propertySet = compilation.GetTypeByMetadataName("DynamicProperty.PropertySet");
                if (propertySet == null) return;

                foreach (var enumSym in enums)
                {
                    if (enumSym.TypeKind != TypeKind.Enum) continue;

                    var sb = new StringBuilder(16 * 1024);
                    var enumName = enumSym.Name;
                    var ns = GetEnclosingNamespace(enumSym) ?? "Global";
                    var extensionsClassName = $"{enumName}PropertySetExtensions";
                    var enumFqn = enumSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    sb.AppendLine("// <auto-generated/>");
                    sb.AppendLine("using System;");
                    sb.AppendLine("using DynamicProperty;");
                    sb.AppendLine();

                    if (ns != "Global")
                    {
                        sb.Append("namespace ").Append(ns).AppendLine();
                        sb.AppendLine("{");
                    }

                    sb.Append("    public static class ").Append(extensionsClassName).AppendLine();
                    sb.AppendLine("    {");

                    bool emittedAny = false;
                    var seenNames = new System.Collections.Generic.HashSet<string>(StringComparer.Ordinal);

                    // Pass 1: per-member methods + collect group candidates
                    var grouped = new System.Collections.Generic.Dictionary<string, GroupBucket>(StringComparer.OrdinalIgnoreCase);

                    foreach (var field in enumSym.GetMembers().OfType<IFieldSymbol>())
                    {
                        if (field.ConstantValue is null) continue; // skip special fields like value__
                        // Find [PropertyType(typeof(...), ...)]
                        var ptAttr = field.GetAttributes().FirstOrDefault(a =>
                            a.AttributeClass?.Name == "PropertyTypeAttribute" ||
                            a.AttributeClass?.ToDisplayString().EndsWith(".PropertyTypeAttribute") == true);
                        if (ptAttr is null) continue;

                        // typeof(T) is the first (or any) Type-typed ctor arg
                        ITypeSymbol? declaredType = null;
                        foreach (var arg in ptAttr.ConstructorArguments)
                        {
                            if (arg.Kind == TypedConstantKind.Type && arg.Value is ITypeSymbol ts)
                            {
                                declaredType = ts;
                                break;
                            }
                        }
                        if (declaredType is null)
                        {
                            context.ReportDiagnostic(DiagMissingType(field));
                            continue;
                        }

                        // Optional [Group("Name")]
                        string? groupName = null;
                        var grpAttr = field.GetAttributes().FirstOrDefault(a =>
                            a.AttributeClass?.Name == "GroupAttribute" ||
                            a.AttributeClass?.ToDisplayString().EndsWith(".GroupAttribute") == true);
                        if (grpAttr != null && grpAttr.ConstructorArguments.Length > 0)
                        {
                            var arg0 = grpAttr.ConstructorArguments[0];
                            if (arg0.Value is string s && !string.IsNullOrWhiteSpace(s))
                                groupName = s.Trim();
                        }

                        var kind = Classify(declaredType);
                        if (kind == ValueKind.Unknown)
                        {
                            context.ReportDiagnostic(DiagUnsupportedType(field, declaredType));
                            continue;
                        }

                        var memberName = field.Name;
                        var safeMemberName = SafeIdentifier(memberName);
                        var idExpr = $"(int){enumFqn}.{memberName}";

                        // Emit scalar methods (including vector/color components as floats)
                        EmitExtensionsForMember(sb, safeMemberName, idExpr, kind, declaredType);
                        emittedAny = true;

                        // [Flags] helpers for enum-valued properties
                        if (kind == ValueKind.Enum32 && IsFlagsEnum(declaredType))
                        {
                            EmitFlagChecksForProperty(sb, declaredType, idExpr, safeMemberName, seenNames);
                            emittedAny = true;
                        }

                        // Collect group components for aggregates (Vector2/3/4/Color)
                        var aggKind = AggregateKindFor(declaredType);
                        if (aggKind != AggregateKind.None && groupName != null)
                        {
                            if (!grouped.TryGetValue(groupName, out var bucket))
                            {
                                bucket = new GroupBucket(groupName, aggKind);
                                grouped[groupName] = bucket;
                            }
                            bucket.AddComponent(field, idExpr);
                        }
                    }

                    // Pass 2: emit aggregates
                    foreach (var kv in grouped)
                    {
                        var bucket = kv.Value;
                        if (!bucket.TryFinalize()) continue; // validate required components
                        EmitAggregate(sb, bucket);
                        emittedAny = true;
                    }

                    sb.AppendLine("    }");

                    if (ns != "Global")
                        sb.AppendLine("}");

                    if (emittedAny)
                        context.AddSource($"{extensionsClassName}.g.cs", sb.ToString());
                }
            }
            catch (Exception ex)
            {
                context.AddSource("PropertySetExtensionsGenerator.Error.g.cs",
                    $"// <auto-generated/> Generator error: {ex}");
            }
        }

        // ---------- [Flags] helpers ----------

        private static bool IsFlagsEnum(ITypeSymbol t)
        {
            // Primary: explicit [Flags] attribute
            foreach (var a in t.GetAttributes())
            {
                var ac = a.AttributeClass;
                if (ac == null) continue;

                var name = ac.Name; // e.g., "FlagsAttribute"
                var fqn = ac.ToDisplayString(); // e.g., "System.FlagsAttribute" or "global::System.FlagsAttribute"
                if (name == "FlagsAttribute") return true;
                if (fqn == "System.FlagsAttribute") return true;
                if (fqn == "global::System.FlagsAttribute") return true;
                if (fqn.EndsWith(".FlagsAttribute", StringComparison.Ordinal)) return true;
            }

            // Heuristic fallback: treat as flags if multiple named values look like single-bit masks
            int bitLike = 0, named = 0;
            foreach (var f in t.GetMembers().OfType<IFieldSymbol>())
            {
                if (f.ConstantValue is null) continue;
                named++;

                // Zero doesn't count as a bit
                if (f.ConstantValue is int iv)
                {
                    if (iv != 0 && (iv & (iv - 1)) == 0) bitLike++;
                }
                else if (f.ConstantValue is long lv)
                {
                    if (lv != 0 && (lv & (lv - 1)) == 0) bitLike++;
                }
            }
            return named > 0 && bitLike >= 2;
        }

        private static void EmitFlagChecksForProperty(
            StringBuilder sb,
            ITypeSymbol enumType,
            string idExpr,
            string owningPropertyName,
            System.Collections.Generic.HashSet<string> seenNames)
        {
            var enumFqn = enumType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach (var flagField in enumType.GetMembers().OfType<IFieldSymbol>())
            {
                if (flagField.ConstantValue is null) continue;
                var flagName = flagField.Name;
                // Optional: skip "None" or synthetic names
                // if (flagName is "None" or "All") continue;

                var methodBase = $"Is{owningPropertyName}{SafeIdentifier(flagName)}";
                var methodName = methodBase;
                if (!seenNames.Add(methodName))
                {
                    methodName = $"{methodBase}_{owningPropertyName}";
                    if (!seenNames.Add(methodName))
                        continue; // avoid collisions
                }

                sb.Append("        public static bool ").Append(methodName)
                  .Append("(this DynamicProperty.PropertySet set)").AppendLine();
                sb.AppendLine("        {");
                sb.AppendLine($"            if (set.TryGetEnum32<{enumFqn}>({idExpr}, out var v))");
                sb.AppendLine($"                return (Convert.ToInt32(v) & (int){enumFqn}.{flagName}) != 0;");
                sb.AppendLine("            return false;");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
        }

        // ---------- group support ----------

        private enum AggregateKind { None, Vector2, Vector3, Vector4, Color }

        private sealed class GroupBucket
        {
            public readonly string GroupName;
            public readonly AggregateKind Kind;

            public (IFieldSymbol sym, string id)? C0;
            public (IFieldSymbol sym, string id)? C1;
            public (IFieldSymbol sym, string id)? C2;
            public (IFieldSymbol sym, string id)? C3;

            public GroupBucket(string name, AggregateKind kind)
            { GroupName = name; Kind = kind; }

            public void AddComponent(IFieldSymbol field, string idExpr)
            {
                var idx = ComponentIndex(field.Name, Kind);
                switch (idx)
                {
                    case 0: C0 = (field, idExpr); break;
                    case 1: C1 = (field, idExpr); break;
                    case 2: C2 = (field, idExpr); break;
                    case 3: C3 = (field, idExpr); break;
                    default:
                        // Fallback: first empty slot if suffix isn't recognized
                        if (C0 is null) C0 = (field, idExpr);
                        else if (C1 is null) C1 = (field, idExpr);
                        else if (C2 is null) C2 = (field, idExpr);
                        else if (C3 is null) C3 = (field, idExpr);
                        break;
                }
            }

            public bool TryFinalize()
            {
                switch (Kind)
                {
                    case AggregateKind.Vector2: return C0 is not null && C1 is not null;
                    case AggregateKind.Vector3: return C0 is not null && C1 is not null && C2 is not null;
                    case AggregateKind.Vector4: return C0 is not null && C1 is not null && C2 is not null && C3 is not null;
                    case AggregateKind.Color: return C0 is not null && C1 is not null && C2 is not null; // A optional
                    default: return false;
                }
            }
        }

        private static int ComponentIndex(string name, AggregateKind kind)
        {
            var n = name.Trim().ToLowerInvariant();
            bool EndsWith(string s) => n.EndsWith(" " + s) || n.EndsWith("." + s) || n.EndsWith(s);

            if (kind == AggregateKind.Color)
            {
                if (EndsWith("r")) return 0;
                if (EndsWith("g")) return 1;
                if (EndsWith("b")) return 2;
                if (EndsWith("a")) return 3;
                return -1;
            }
            else
            {
                if (EndsWith("x")) return 0;
                if (EndsWith("y")) return 1;
                if (EndsWith("z")) return 2;
                if (EndsWith("w")) return 3;
                return -1;
            }
        }

        private static AggregateKind AggregateKindFor(ITypeSymbol t)
        {
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::UnityEngine.Vector2") return AggregateKind.Vector2;
            if (fqn == "global::UnityEngine.Vector3") return AggregateKind.Vector3;
            if (fqn == "global::UnityEngine.Vector4") return AggregateKind.Vector4;
            if (fqn == "global::UnityEngine.Color") return AggregateKind.Color;
            return AggregateKind.None;
        }

        private static string SanitizeGroupName(string s)
        {
            var sb = new StringBuilder(s.Length);
            foreach (var ch in s)
                if (!char.IsWhiteSpace(ch)) sb.Append(ch);
            if (sb.Length == 0 || SyntaxFacts.GetKeywordKind(sb.ToString()) != SyntaxKind.None)
                return "_" + sb.ToString();
            return sb.ToString();
        }

        private static void EmitAggregate(StringBuilder sb, GroupBucket g)
        {
            var name = SanitizeGroupName(g.GroupName);

            switch (g.Kind)
            {
                case AggregateKind.Vector2:
                    sb.AppendLine($"        public static global::UnityEngine.Vector2 {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float x = set.TryGetFloat({g.C0!.Value.id}, out var vx) ? vx : 0f;");
                    sb.AppendLine($"            float y = set.TryGetFloat({g.C1!.Value.id}, out var vy) ? vy : 0f;");
                    sb.AppendLine("            return new global::UnityEngine.Vector2(x,y);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Vector2 v)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, v.x);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, v.y);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;

                case AggregateKind.Vector3:
                    sb.AppendLine($"        public static global::UnityEngine.Vector3 {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float x = set.TryGetFloat({g.C0!.Value.id}, out var vx) ? vx : 0f;");
                    sb.AppendLine($"            float y = set.TryGetFloat({g.C1!.Value.id}, out var vy) ? vy : 0f;");
                    sb.AppendLine($"            float z = set.TryGetFloat({g.C2!.Value.id}, out var vz) ? vz : 0f;");
                    sb.AppendLine("            return new global::UnityEngine.Vector3(x,y,z);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Vector3 v)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, v.x);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, v.y);");
                    sb.AppendLine($"            set.SetFloat({g.C2!.Value.id}, v.z);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;

                case AggregateKind.Vector4:
                    sb.AppendLine($"        public static global::UnityEngine.Vector4 {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float x = set.TryGetFloat({g.C0!.Value.id}, out var vx) ? vx : 0f;");
                    sb.AppendLine($"            float y = set.TryGetFloat({g.C1!.Value.id}, out var vy) ? vy : 0f;");
                    sb.AppendLine($"            float z = set.TryGetFloat({g.C2!.Value.id}, out var vz) ? vz : 0f;");
                    sb.AppendLine($"            float w = set.TryGetFloat({g.C3!.Value.id}, out var vw) ? vw : 0f;");
                    sb.AppendLine("            return new global::UnityEngine.Vector4(x,y,z,w);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Vector4 v)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, v.x);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, v.y);");
                    sb.AppendLine($"            set.SetFloat({g.C2!.Value.id}, v.z);");
                    sb.AppendLine($"            set.SetFloat({g.C3!.Value.id}, v.w);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id}) || set.ContainsAny({g.C3!.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;

                case AggregateKind.Color:
                    sb.AppendLine($"        public static global::UnityEngine.Color {name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            float r = set.TryGetFloat({g.C0!.Value.id}, out var vr) ? vr : 0f;");
                    sb.AppendLine($"            float g_ = set.TryGetFloat({g.C1!.Value.id}, out var vg) ? vg : 0f;");
                    sb.AppendLine($"            float b = set.TryGetFloat({g.C2!.Value.id}, out var vb) ? vb : 0f;");
                    if (g.C3 is null)
                        sb.AppendLine("            float a = 1f;");
                    else
                        sb.AppendLine($"            float a = set.TryGetFloat({g.C3.Value.id}, out var va) ? va : 1f;");
                    sb.AppendLine("            return new global::UnityEngine.Color(r,g_,b,a);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static void Set{name}(this DynamicProperty.PropertySet set, global::UnityEngine.Color c)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            set.SetFloat({g.C0!.Value.id}, c.r);");
                    sb.AppendLine($"            set.SetFloat({g.C1!.Value.id}, c.g);");
                    sb.AppendLine($"            set.SetFloat({g.C2!.Value.id}, c.b);");
                    if (g.C3 is not null)
                        sb.AppendLine($"            set.SetFloat({g.C3.Value.id}, c.a);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public static bool Has{name}(this DynamicProperty.PropertySet set)");
                    sb.AppendLine("        {");
                    if (g.C3 is null)
                        sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id});");
                    else
                        sb.AppendLine($"            return set.ContainsAny({g.C0!.Value.id}) || set.ContainsAny({g.C1!.Value.id}) || set.ContainsAny({g.C2!.Value.id}) || set.ContainsAny({g.C3.Value.id});");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    break;
            }
        }

        // ---------- general utilities ----------

        private static void CollectEnumsFromNamespace(INamespaceSymbol ns, System.Collections.Generic.List<INamedTypeSymbol> sink)
        {
            foreach (var t in ns.GetTypeMembers())
                if (t.TypeKind == TypeKind.Enum) sink.Add(t);
            foreach (var child in ns.GetNamespaceMembers())
                CollectEnumsFromNamespace(child, sink);
        }

        private static string? GetEnclosingNamespace(INamedTypeSymbol t)
        {
            var ns = t.ContainingNamespace;
            if (ns == null || ns.IsGlobalNamespace) return null;
            return ns.ToDisplayString();
        }

        private enum ValueKind { Int32, Single, Boolean, Int64, Double, DateTime, TimeSpan, Enum32, Unknown }

        private static ValueKind Classify(ITypeSymbol t)
        {
            switch (t.SpecialType)
            {
                case SpecialType.System_Int32: return ValueKind.Int32;
                case SpecialType.System_Single: return ValueKind.Single;
                case SpecialType.System_Boolean: return ValueKind.Boolean;
                case SpecialType.System_Int64: return ValueKind.Int64;
                case SpecialType.System_Double: return ValueKind.Double;
                case SpecialType.System_DateTime: return ValueKind.DateTime;
            }
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::System.TimeSpan") return ValueKind.TimeSpan;
            if (fqn == "global::UnityEngine.Vector2" ||
                fqn == "global::UnityEngine.Vector3" ||
                fqn == "global::UnityEngine.Vector4" ||
                fqn == "global::UnityEngine.Color")
                return ValueKind.Single; // components are floats
            if (t.TypeKind == TypeKind.Enum) return ValueKind.Enum32;
            return ValueKind.Unknown;
        }

        private static void EmitExtensionsForMember(StringBuilder sb, string name, string idExpr, ValueKind kind, ITypeSymbol declaredType)
        {
            var typeName = GetClrTypeName(kind, declaredType);

            // Getter
            sb.Append("        public static ").Append(typeName).Append(' ').Append(name)
              .Append("(this DynamicProperty.PropertySet set)").AppendLine();
            sb.AppendLine("        {");
            switch (kind)
            {
                case ValueKind.Int32: sb.AppendLine($"            return set.TryGetInt({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Single: sb.AppendLine($"            return set.TryGetFloat({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Boolean: sb.AppendLine($"            return set.TryGetBool({idExpr}, out var v) && v;"); break;
                case ValueKind.Int64: sb.AppendLine($"            return set.TryGetLong({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Double: sb.AppendLine($"            return set.TryGetDouble({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.DateTime: sb.AppendLine($"            return set.TryGetDateTime({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.TimeSpan: sb.AppendLine($"            return set.TryGetTimeSpan({idExpr}, out var v) ? v : default;"); break;
                case ValueKind.Enum32:
                    var enumTypeName = declaredType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine($"            return set.TryGetEnum32<{enumTypeName}>({idExpr}, out var v) ? v : default;");
                    break;
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Setter
            sb.Append("        public static void Set").Append(name)
              .Append("(this DynamicProperty.PropertySet set, ").Append(typeName).Append(" value)").AppendLine();
            sb.AppendLine("        {");
            switch (kind)
            {
                case ValueKind.Int32: sb.AppendLine($"            set.SetInt({idExpr}, value);"); break;
                case ValueKind.Single: sb.AppendLine($"            set.SetFloat({idExpr}, value);"); break;
                case ValueKind.Boolean: sb.AppendLine($"            set.SetBool({idExpr}, value);"); break;
                case ValueKind.Int64: sb.AppendLine($"            set.SetLong({idExpr}, value);"); break;
                case ValueKind.Double: sb.AppendLine($"            set.SetDouble({idExpr}, value);"); break;
                case ValueKind.DateTime: sb.AppendLine($"            set.SetDateTime({idExpr}, value);"); break;
                case ValueKind.TimeSpan: sb.AppendLine($"            set.SetTimeSpan({idExpr}, value);"); break;
                case ValueKind.Enum32:
                    var enumTypeName = declaredType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine($"            set.SetEnum32<{enumTypeName}>({idExpr}, value);");
                    break;
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Presence
            sb.Append("        public static bool Has").Append(name)
              .Append("(this DynamicProperty.PropertySet set)").AppendLine();
            sb.AppendLine("        {");
            sb.AppendLine($"            return set.ContainsAny({idExpr});");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private static string GetClrTypeName(ValueKind kind, ITypeSymbol declaredType) =>
            kind switch
            {
                ValueKind.Int32 => "int",
                ValueKind.Single => "float",
                ValueKind.Boolean => "bool",
                ValueKind.Int64 => "long",
                ValueKind.Double => "double",
                ValueKind.DateTime => "global::System.DateTime",
                ValueKind.TimeSpan => "global::System.TimeSpan",
                ValueKind.Enum32 => declaredType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                _ => "object"
            };

        private static string SafeIdentifier(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return "_";
            if (SyntaxFacts.GetKeywordKind(raw) != SyntaxKind.None) return "@" + raw;
            return raw.Replace('<', '_').Replace('>', '_');
        }

        // Diagnostics
        private static Diagnostic DiagMissingType(IFieldSymbol field) =>
            Diagnostic.Create(new DiagnosticDescriptor(
                id: "DP1001", title: "PropertyType attribute missing type",
                messageFormat: "Enum member '{0}' has [PropertyType(...)] but no typeof(T) argument.",
                category: "DynamicProperty.SourceGen",
                defaultSeverity: DiagnosticSeverity.Warning, isEnabledByDefault: true),
                field.Locations.FirstOrDefault(), field.Name);

        private static Diagnostic DiagUnsupportedType(IFieldSymbol field, ITypeSymbol type) =>
            Diagnostic.Create(new DiagnosticDescriptor(
                id: "DP1002", title: "Unsupported PropertyType",
                messageFormat: "Enum member '{0}' uses unsupported PropertyType '{1}'.",
                category: "DynamicProperty.SourceGen",
                defaultSeverity: DiagnosticSeverity.Warning, isEnabledByDefault: true),
                field.Locations.FirstOrDefault(), field.Name, type.ToDisplayString());
    }
}
